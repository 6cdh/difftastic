=======================================
Built-in types
=======================================

var x: string = 'hi';
var y: number;

---

(program
  (variable_declaration (variable_declarator
    (identifier)
    (type_annotation (predefined_type))
    (string)))
  (variable_declaration (variable_declarator
    (identifier)
    (type_annotation (predefined_type)))))

=======================================
Parenthesized types
=======================================

var x: (string);

---

(program
  (variable_declaration (variable_declarator
    (identifier)
    (type_annotation (parenthesized_type (predefined_type))))))

=======================================
Object types
=======================================

let person: {name: string, age: number};

---

(program
  (lexical_declaration (variable_declarator
    (identifier)
    (type_annotation (object_type
      (property_signature (identifier) (type_annotation (predefined_type)))
      (property_signature (identifier) (type_annotation (predefined_type))))))))

=======================================
Array types
=======================================

let x: X[];

---

(program
  (lexical_declaration (variable_declarator
    (identifier)
    (type_annotation (array_type (type_reference (identifier)))))))

=======================================
Function types
=======================================

let x: (result: string) => any;

---

(program
  (lexical_declaration (variable_declarator
    (identifier)
    (type_annotation
      (function_type
        (formal_parameters
          (required_parameter (identifier) (type_annotation (predefined_type))))
        (predefined_type))))))

=======================================
Constructor types
=======================================

let x: new < T1, T2 > ( p1, p2 ) => R;

---

(program
  (lexical_declaration (variable_declarator
    (identifier)
    (type_annotation
      (constructor_type
        (type_parameters (type_parameter (identifier)) (type_parameter (identifier)))
        (formal_parameters
          (required_parameter (identifier)) (required_parameter (identifier)))
        (type_reference (identifier)))))))


=======================================
Type annotations in parenthesized expressions
=======================================

const range = (document: any).selection.createRange()

---

(program
  (lexical_declaration (variable_declarator
    (identifier)
  (function_call
  (member_access
    (member_access (identifier) (type_annotation (predefined_type)) (identifier))
    (identifier))
  (arguments)))))

=======================================
Flow Maybe Types
=======================================

const editor: ?CodeEditor
const miscArray: ?T[]

---

(program
  (lexical_declaration (variable_declarator
    (identifier)
    (type_annotation (flow_maybe_type (type_reference (identifier))))))
  (lexical_declaration (variable_declarator
    (identifier)
    (type_annotation (flow_maybe_type (array_type (type_reference (identifier))))))))

=======================================
Flow Import Types
=======================================

import type {UserID, User} from "./User.js";
import typeof {jimiguitar as GuitarT} from "./User.js";

---

(program
  (import_statement
    (import_clause
      (named_imports (import_specifier (identifier)) (import_specifier (identifier)))) (string))
  (import_statement
    (import_clause
      (named_imports (import_specifier (identifier) (identifier)))) (string)))

=======================================
Type alias declarations
=======================================

type FileMergeData = {
  document: Doc,
  headDocument: Doc,
  baseDocument: Doc,
  conflicts: ConflictInfo[]
}

type ConflictInfo = {
  start?: LineHandle,
  middle?: LineHandle,
  end?: LineHandle
}

---

(program
  (type_alias_declaration
    (identifier)
    (object_type
      (property_signature (identifier) (type_annotation (type_reference (identifier))))
      (property_signature (identifier) (type_annotation (type_reference (identifier))))
      (property_signature (identifier) (type_annotation (type_reference (identifier))))
      (property_signature (identifier) (type_annotation (array_type (type_reference (identifier)))))))

  (type_alias_declaration
    (identifier)
    (object_type
      (property_signature (identifier) (type_annotation (type_reference (identifier))))
      (property_signature (identifier) (type_annotation (type_reference (identifier))))
      (property_signature (identifier) (type_annotation (type_reference (identifier)))))))

=======================================
Enum declarations
=======================================

enum Test {
    A,
    B,
    C = Math.floor(Math.random() * 1000),
    D = 10,
    E
}

enum Style {
    None = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    Emphasis = Bold | Italic,
    Hyperlink = Bold | Underline
}

---

(program
  (enum_declaration
    (identifier)
    (identifier)
    (identifier)
    (enum_assignment
      (identifier)
      (function_call
        (member_access (identifier) (identifier))
        (arguments (math_op (function_call (member_access (identifier) (identifier)) (arguments)) (number)))))
    (enum_assignment (identifier) (number))
    (identifier))
  (enum_declaration
    (identifier)
    (enum_assignment (identifier) (number))
    (enum_assignment (identifier) (number))
    (enum_assignment (identifier) (number))
    (enum_assignment (identifier) (number))
    (enum_assignment (identifier) (bitwise_op (identifier) (identifier)))
    (enum_assignment (identifier) (bitwise_op (identifier) (identifier)))))

=======================================
Interface declarations
=======================================

interface A { a: string; }

interface B extends A { b: string; }

interface Friend {
    name: string;
    favoriteColor?: string;
}

interface G<T, U extends B> {
    x: T;
    y: U;
}

interface X {
  hook: {
  }
  get(key: Key): Promise<T>;
}

---

(program
  (interface_declaration
    (identifier)
    (object_type (property_signature (identifier) (type_annotation (predefined_type)))))
  (interface_declaration
    (identifier)
    (extends_clause (type_reference (identifier)))
    (object_type (property_signature (identifier) (type_annotation (predefined_type)))))
  (interface_declaration
    (identifier)
    (object_type
      (property_signature (identifier) (type_annotation (predefined_type)))
      (property_signature (identifier) (type_annotation (predefined_type)))))
  (interface_declaration
    (identifier)
    (type_parameters (type_parameter (identifier)) (type_parameter (identifier) (constraint (type_reference (identifier)))))
    (object_type
      (property_signature (identifier) (type_annotation (type_reference (identifier))))
      (property_signature (identifier) (type_annotation (type_reference (identifier))))))
  (interface_declaration
    (identifier)
    (object_type
      (property_signature (identifier) (type_annotation (object_type)))
      (method_signature
        (reserved_identifier)
        (call_signature
          (formal_parameters
            (required_parameter (identifier) (type_annotation (type_reference (identifier)))))
          (type_annotation
            (type_reference (identifier) (type_arguments (type_reference (identifier))))))))))

=======================================
Existential types
=======================================

let x: Array<*>

---

(program
  (lexical_declaration (variable_declarator
    (identifier)
    (type_annotation (type_reference (identifier) (type_arguments (existential_type)))))))

=======================================
Flow Union types
=======================================

type U = number | string;

---

(program
  (type_alias_declaration (identifier) (union_type (predefined_type) (predefined_type))))

=======================================
Flow Intersection types
=======================================

type BrowserStats$ResourceTiming = number & string;

---

(program (type_alias_declaration (identifier) (intersection_type (predefined_type) (predefined_type))))

=======================================
Flow exact object types
=======================================

type BrowserStats = {|
  url: string,
  ms: number
|}

---

(program
  (type_alias_declaration
    (identifier)
    (object_type
      (property_signature (identifier) (type_annotation (predefined_type)))
      (property_signature (identifier) (type_annotation (predefined_type))))))


=======================================
Literal types
=======================================

let x: 2
let x: 2 | 3 | 4
let x: "string"
let x: false

---

(program
  (lexical_declaration
    (variable_declarator (identifier) (type_annotation (literal_type (number)))))
  (lexical_declaration
    (variable_declarator (identifier) (type_annotation (union_type (union_type (literal_type (number)) (literal_type (number))) (literal_type (number))))))
  (lexical_declaration
    (variable_declarator (identifier) (type_annotation (literal_type (string))))) (lexical_declaration (variable_declarator (identifier) (type_annotation (literal_type (false))))))

=======================================
Flow type parameter constraint syntax
=======================================

type HandlerFunction<T: Element> = void

---

(program
  (type_alias_declaration
    (identifier)
    (type_parameters (type_parameter (identifier) (constraint (type_reference (identifier)))))
  (predefined_type)))


=======================================
Nested type arguments
=======================================

interface X {
  x(): Promise<Array<Foo> >;
}

---

(program
  (interface_declaration
    (identifier)
    (object_type
      (method_signature
        (identifier)
        (call_signature
          (formal_parameters)
          (type_annotation
            (type_reference
              (identifier)
              (type_arguments
                (type_reference (identifier) (type_arguments (type_reference (identifier))))))))))))

=======================================
predefined types as identifiers
=======================================

let score: (string: string, query: string) => number

---

(program
  (lexical_declaration (variable_declarator
    (identifier)
    (type_annotation
    (function_type
      (formal_parameters
        (required_parameter (parameter_identifier) (type_annotation (predefined_type)))
        (required_parameter (identifier) (type_annotation (predefined_type))))
      (predefined_type))))))

=======================================
Non-null assertion operator
=======================================

const repository = foo++!

---

(program (lexical_declaration (variable_declarator (identifier) (non_null_assertion_op (math_op (identifier))))))

